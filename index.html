<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="robots" content="noindex,nofollow">
  <title>Scratch Adventure ü´Äü´Ç</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
    html,body{height:100%;overflow:hidden}
    body{
      font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
      background:linear-gradient(135deg,#ff9a9e 0%,#fecfef 50%,#fecfef 100%);
      color:#fff;touch-action:none;position:fixed;width:100%;height:100%
    }

    /* ===== FLOATING PARTICLES ===== */
    .particles{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0}
    .particle{
      position:absolute;border-radius:50%;
      animation:float 8s infinite ease-in-out;
      opacity:0;
    }
    .particle.heart{width:14px;height:14px;background:#ff6b6b}
    .particle.dot1{width:10px;height:10px;background:#ffd93d}
    .particle.dot2{width:12px;height:12px;background:#4CAF50}
    .particle.dot3{width:8px;height:8px;background:#2196F3}
    .particle.dot4{width:11px;height:11px;background:#9C27B0}
    @keyframes float{
      0%, 100%{transform:translateY(0) translateX(0) scale(1);opacity:.8}
      25%{transform:translateY(-15px) translateX(calc(var(--drift) * 0.3)) scale(0.9);opacity:.9}
      50%{transform:translateY(-5px) translateX(calc(var(--drift) * -0.2)) scale(0.85);opacity:.8}
      75%{transform:translateY(-20px) translateX(calc(var(--drift) * 0.5)) scale(0.95);opacity:.9}
    }

    /* ===== TEDDY IMAGES ===== */
    .teddy-welcome{
      width:220px;
      height:220px;
      margin-bottom:20px;
      animation:glow 2s ease-in-out infinite alternate, titlePulse 2.5s ease-in-out infinite;
    }
    .teddy-game{
      width:180px;
      height:180px;
      margin-bottom:15px;
    }

    /* ===== POPUPS ===== */
    .popup-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:none;align-items:center;justify-content:center;z-index:1000}
    .popup{background:#fff;padding:30px;border-radius:20px;text-align:center;max-width:90%;box-shadow:0 10px 40px rgba(0,0,0,.3);min-width:300px}
    .popup h3{margin-bottom:15px;color:#333;font-size:1.5em}
    .popup p{color:#666;margin-bottom:15px;font-size:0.9em}
    .popup input{padding:12px;border:2px solid #ff6b6b;border-radius:25px;width:100%;margin:15px 0;font-size:1em;transition:border-color .3s}
    .popup input:focus{outline:none;border-color:#ff8787}
    .popup button{padding:12px 30px;margin:5px;border:none;border-radius:20px;cursor:pointer;font-weight:bold;font-size:1em;transition:all .3s}
    .popup button:first-of-type{background:#4CAF50;color:#fff}
    .popup button:first-of-type:hover{background:#66BB6A;transform:translateY(-2px)}
    .popup button:last-of-type{background:#ff6b6b;color:#fff}
    .popup button:last-of-type:hover{background:#ff8787;transform:translateY(-2px)}

    /* ===== LOADING SPINNER ===== */
    .loading-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:2000}
    .spinner{width:50px;height:50px;border:5px solid rgba(255,255,255,.3);border-top-color:#ff6b6b;border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* ===== WELCOME SCREEN + ANIMATIONS ===== */
    .welcome-screen{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;position:relative;z-index:1}
    .main-title{
      font-size:clamp(2.5em,8vw,4em);margin-bottom:30px;
      background:linear-gradient(45deg,#ff6b6b,#ffd93d);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      animation:glow 2s ease-in-out infinite alternate, titlePulse 2.5s ease-in-out infinite;
    }
    @keyframes glow{from{filter:drop-shadow(0 0 10px rgba(255,107,107,.5))}to{filter:drop-shadow(0 0 20px rgba(255,217,61,.8))}}
    @keyframes titlePulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}
    .create-btn{
      padding:18px 50px;font-size:1.2em;
      background:linear-gradient(45deg,#ff6b6b,#ff8787);
      border:none;border-radius:50px;color:#fff;cursor:pointer;font-weight:bold;
      box-shadow:0 10px 30px rgba(255,107,107,.4);
      animation:btnFloat 3s ease-in-out infinite;
      transition:all .3s;
    }
    @keyframes btnFloat{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
    .create-btn:hover{transform:translateY(-5px) scale(1.05);box-shadow:0 15px 40px rgba(255,107,107,.6)}

    /* ===== GAME SCREEN ===== */
    .game-screen{display:none;flex-direction:column;height:100vh;position:relative;z-index:1}
    .top-bar{display:flex;justify-content:space-between;align-items:center;padding:15px 20px;background:rgba(0,0,0,.1);backdrop-filter:blur(10px);position:fixed;top:0;left:0;right:0;z-index:100}
    .top-btn{width:45px;height:45px;border:none;border-radius:50%;background:rgba(255,255,255,.2);color:#fff;font-size:18px;cursor:pointer;backdrop-filter:blur(10px);display:flex;align-items:center;justify-content:center;transition:all .3s}
    .top-btn:active{transform:scale(.9)}
    .connection-status{position:fixed;top:60px;left:50%;transform:translateX(-50%);z-index:150;background:rgba(0,0,0,.7);color:#fff;padding:8px 16px;border-radius:20px;font-size:0.8em;opacity:0;transition:opacity .3s}
    .connection-status.show{opacity:1}
    .center-content{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:20px;padding-top:90px;padding-bottom:90px}
    .game-title{font-size:clamp(1.8em,6vw,2.5em);margin-bottom:10px;text-shadow:2px 2px 4px rgba(0,0,0,.2);color:#000;text-align:center;line-height:1.2}
    .instruction{font-size:clamp(1em,3vw,1.2em);margin-bottom:15px;color:#333;font-weight:500;text-align:center}
    .turn-indicator{margin:10px 0;font-size:clamp(1.1em,4vw,1.3em);font-weight:bold;animation:pulse 1.5s infinite;color:#333;text-align:center;line-height:1.3;min-height:30px}
    @keyframes pulse{0%,100%{opacity:.7}50%{opacity:1}}
    .name-plate{background:linear-gradient(45deg,gold,#ffd700);padding:10px 25px;border-radius:25px;font-size:clamp(12px,3vw,15px);color:#333;font-weight:bold;box-shadow:0 5px 15px rgba(0,0,0,.2);margin:10px 0;text-align:center;max-width:90%;word-break:break-word}
    .dare-box{position:relative;width:min(350px,90vw);height:120px;margin:20px 0;border-radius:15px;overflow:hidden;box-shadow:0 5px 20px rgba(0,0,0,.2)}
    #scratchCanvas{position:absolute;top:0;left:0;width:100%;height:100%;cursor:crosshair;border-radius:15px;z-index:2;touch-action:none}
    #dareText{position:absolute;width:100%;height:100%;display:flex;align-items:center;justify-content:center;text-align:center;color:#333;font-weight:bold;font-size:clamp(14px,3vw,17px);padding:15px;background:#fff;border-radius:15px;z-index:1;line-height:1.4;word-wrap:break-word}
    .complete-btn{padding:15px 40px;font-size:clamp(1em,3vw,1.1em);background:linear-gradient(45deg,#4CAF50,#66BB6A);border:none;border-radius:30px;color:#fff;cursor:pointer;font-weight:bold;margin:20px 0;transition:all .3s;text-align:center}
    .complete-btn:hover{transform:scale(1.05);box-shadow:0 8px 25px rgba(76,175,80,.4)}
    .complete-btn:disabled{background:#ccc!important;cursor:not-allowed!important;transform:scale(1)!important;opacity:.6}
    .bottom-bar{display:flex;justify-content:space-between;align-items:center;padding:15px 20px;background:rgba(0,0,0,.1);backdrop-filter:blur(10px);position:fixed;bottom:0;left:0;right:0;z-index:100}
    .profile-status{display:flex;align-items:center;gap:10px;font-size:clamp(12px,2.5vw,14px);color:#333;font-weight:500}
    .profile-icon{width:35px;height:35px;border-radius:50%;background:#ff6b6b;display:flex;align-items:center;justify-content:center;font-size:18px;color:#fff}
    .creator-info{color:#333;font-size:clamp(10px,2vw,.9em);text-align:center}
    .status-dot{width:8px;height:8px;border-radius:50%;display:inline-block;margin-left:5px;box-shadow:0 0 5px rgba(0,0,0,.2)}
    .status-online{background:#4CAF50;animation:blink 1.5s infinite}
    .status-offline{background:#ccc}
    @keyframes blink{0%,100%{opacity:1}50%{opacity:.5}}
    .hidden{display:none!important}
    
    /* Error toast */
    .error-toast{position:fixed;bottom:100px;left:50%;transform:translateX(-50%) translateY(100px);background:#ff6b6b;color:#fff;padding:12px 24px;border-radius:25px;z-index:2000;opacity:0;transition:transform .3s, opacity .3s;font-size:0.9em;font-weight:bold}
    .error-toast.show{transform:translateX(-50%) translateY(0);opacity:1}
  </style>
</head>
<body>
  <!-- ===== FLOATING PARTICLES ===== -->
  <div class="particles" id="particles"></div>

  <!-- ===== LOADING OVERLAY ===== -->
  <div class="loading-overlay" id="loadingOverlay"><div class="spinner"></div></div>

  <!-- ===== CONNECTION STATUS ===== -->
  <div class="connection-status" id="connectionStatus">Connecting...</div>

  <!-- ===== ERROR TOAST ===== -->
  <div class="error-toast" id="errorToast"></div>

  <!-- ===== POPUPS ===== -->
  <div class="popup-overlay" id="exitConfirm"><div class="popup"><h3>‚ùå Exit Game?</h3><p>Are you sure you want to leave?</p><button onclick="exitGame()">Confirm</button><button onclick="closeExitPopup()">Cancel</button></div></div>
  <div class="popup-overlay" id="roomPopup"><div class="popup"><h3>üéÆ Join Adventure</h3><input type="text" id="roomNameInput" placeholder="Enter your name..." maxlength="20"><button onclick="createRoom()">Create/Join</button><button onclick="closeRoomPopup()">Cancel</button></div></div>
  <div class="popup-overlay" id="invitePopup"><div class="popup"><h3>üîó Invite Friend</h3><input type="text" id="inviteLink" readonly><button onclick="copyLink()">Copy Link</button><button onclick="closeInvitePopup()">Close</button></div></div>

  <!-- ===== WELCOME SCREEN ===== -->
  <div class="welcome-screen" id="welcomeScreen">
    <img src="teddy.png" class="teddy-welcome" alt="Teddy" onerror="this.style.display='none'">
    <h1 class="main-title">üíï Scratch Adventure üíï</h1>
    <button class="create-btn" onclick="showRoomPopup()">Start Adventure</button>
  </div>

  <!-- ===== GAME SCREEN ===== -->
  <div class="game-screen" id="gameScreen">
    <div class="top-bar">
      <button class="top-btn exit-btn" onclick="showExitConfirm()">‚ùå</button>
      <button class="top-btn invite-btn" id="inviteBtn" onclick="showInvitePopup()">üîó</button>
    </div>
    <div class="center-content">
      <img src="teddy.png" class="teddy-game" alt="Teddy" onerror="this.style.display='none'">
      <h2 class="game-title">üéÄScratch AdventureüéÄ</h2>
      <p class="instruction">Scratch the red ‚ô•Ô∏è field with your finger</p>
      <div class="turn-indicator" id="turnIndicator">Preparing game...</div>
      <div class="name-plate" id="creatorName">Room</div>
      <div class="dare-box" id="dareBox">
        <canvas id="scratchCanvas"></canvas>
        <div id="dareText">ü´ÄScratch to reveal!</div>
      </div>
      <button class="complete-btn hidden" id="completeBtn" onclick="completeDare()">‚úÖ Dare Completed</button>
    </div>
    <div class="bottom-bar">
      <div class="profile-status"><div class="profile-icon">üë§</div><span id="joinerStatus">Partner <span class="status-dot status-offline"></span></span></div>
      <div class="creator-info">Created by urluv_harrryyy</div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ===== CONFIG =====
    const CONFIG = {
      SCRATCH_THRESHOLD: 0.25,
      CANVAS_BASE_WIDTH: 350,
      CANVAS_BASE_HEIGHT: 120,
      SCRATCH_RADIUS: 25,
      PIXEL_SAMPLE_RATE: 40,
      ACTIVE_CHECK_INTERVAL: 2000,
      SCRATCH_DEBOUNCE_MS: 50,
      CONNECTION_TIMEOUT_MS: 5000,
      MAX_RECONNECT_ATTEMPTS: 5
    };

    // ===== STATE MANAGEMENT =====
    const state = {
      socket: null,
      currentRole: '',
      currentRoom: '',
      creatorName: '',
      hasScratched: false,
      isMyTurn: false,
      joinerJoined: false,
      isPageActive: true,
      lastScratchX: 0,
      lastScratchY: 0,
      reconnectionAttempts: 0,
      isConnected: false
    };

    // ===== STORAGE HELPERS =====
    const Storage = {
      save() {
        try {
          sessionStorage.setItem('adventure_state', JSON.stringify({
            currentRoom: state.currentRoom,
            currentRole: state.currentRole,
            creatorName: state.creatorName
          }));
        } catch (e) {
          console.warn('Storage unavailable:', e);
        }
      },
      load() {
        try {
          const saved = sessionStorage.getItem('adventure_state');
          return saved ? JSON.parse(saved) : null;
        } catch (e) {
          console.warn('Storage load failed:', e);
          return null;
        }
      },
      clear() {
        try {
          sessionStorage.removeItem('adventure_state');
        } catch (e) {
          console.warn('Storage clear failed:', e);
        }
      }
    };

    // ===== FLOATING PARTICLES =====
    function createParticles(){
      const container = document.getElementById('particles');
      const colors = ['heart','dot1','dot2','dot3','dot4'];
      for (let i = 0; i < 25; i++){
        const p = document.createElement('div');
        const type = colors[Math.floor(Math.random()*colors.length)];
        p.className = 'particle '+type;
        p.style.left = Math.random()*100 + '%';
        p.style.top = Math.random()*100 + '%';
        p.style.setProperty('--drift', (Math.random()*60 - 30) + 'px');
        p.style.animationDelay = Math.random()*8 + 's';
        p.style.animationDuration = (8 + Math.random()*4) + 's';
        container.appendChild(p);
      }
    }
    createParticles();

    // ===== UI HELPERS =====
    function showLoading(message = 'Loading...') {
      const overlay = document.getElementById('loadingOverlay');
      overlay.style.display = 'flex';
    }

    function hideLoading() {
      document.getElementById('loadingOverlay').style.display = 'none';
    }

    function showConnectionStatus(message) {
      const status = document.getElementById('connectionStatus');
      status.textContent = message;
      status.classList.add('show');
      setTimeout(() => status.classList.remove('show'), 3000);
    }

    function showError(message) {
      const toast = document.getElementById('errorToast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 5000);
    }

    function showRoomPopup(){document.getElementById('roomPopup').style.display='flex'}
    function closeRoomPopup(){document.getElementById('roomPopup').style.display='none'}

    function showInvitePopup(){
      const base = window.location.origin + window.location.pathname.replace(/\/$/,'');
      document.getElementById('inviteLink').value = `${base}?room=${encodeURIComponent(state.currentRoom)}`;
      document.getElementById('invitePopup').style.display='flex';
    }
    function closeInvitePopup(){document.getElementById('invitePopup').style.display='none'}

    function showExitConfirm(){document.getElementById('exitConfirm').style.display='flex'}
    function closeExitPopup(){document.getElementById('exitConfirm').style.display='none'}

    // ===== SOCKET SETUP =====
    function initSocket() {
      if (state.socket) {
        state.socket.disconnect();
      }

      state.socket = io({
        reconnection: true,
        reconnectionAttempts: CONFIG.MAX_RECONNECT_ATTEMPTS,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: CONFIG.CONNECTION_TIMEOUT_MS
      });

      // Connection events
      state.socket.on('connect', () => {
        console.log('[SOCKET] Connected');
        state.isConnected = true;
        state.reconnectionAttempts = 0;
        showConnectionStatus('‚úÖ Connected');
        
        // Attempt to rejoin if we have saved state
        const saved = Storage.load();
        if (saved && saved.currentRoom) {
          showConnectionStatus('üîÑ Rejoining room...');
          state.socket.emit('join', {
            room: saved.currentRoom,
            name: saved.creatorName
          });
        }
      });

      state.socket.on('disconnect', (reason) => {
        console.log('[SOCKET] Disconnected:', reason);
        state.isConnected = false;
        showConnectionStatus('‚ö†Ô∏è Disconnected. Reconnecting...');
      });

      state.socket.on('connect_error', (error) => {
        console.error('[SOCKET] Connection error:', error);
        state.reconnectionAttempts++;
        showConnectionStatus(`‚ùå Connection failed (${state.reconnectionAttempts})`);
        
        if (state.reconnectionAttempts >= CONFIG.MAX_RECONNECT_ATTEMPTS) {
          showError('Failed to reconnect. Please refresh the page.');
        }
      });

      // Game events
      state.socket.on('room-check-result', (result) => {
        if (!result.valid) {
          showError(result.error || 'Invalid room');
          hideLoading();
          window.location.href = window.location.pathname;
        }
      });

      state.socket.on('role', (data) => {
        state.currentRole = data.role;
        state.creatorName = data.name;
        state.isMyTurn = (data.role === ROLE_CREATOR);
        Storage.save();
        console.log(`[GAME] Assigned role: ${data.role}`);
        updateUI();
      });

      state.socket.on('state', (roomData) => {
        state.joinerJoined = roomData.joiner.connected;
        state.hasScratched = roomData.scratched;
        state.currentRoom = roomData.id;
        
        document.getElementById('dareText').textContent = roomData.scratched ? 
          roomData.dare : '‚ô•Ô∏è Scratch to reveal!';
        
        if (!roomData.scratched) {
          setupCanvas();
          document.getElementById('completeBtn').classList.add('hidden');
        } else {
          document.getElementById('completeBtn').classList.remove('hidden');
        }
        
        Storage.save();
        hideLoading();
        updateUI();
      });

      state.socket.on('joiner-joined', (data) => {
        state.joinerJoined = true;
        document.getElementById('inviteBtn').style.display = 'none';
        updateUI();
        showConnectionStatus('üë§ Partner joined!');
      });

      state.socket.on('joiner-status', (data) => {
        state.joinerJoined = data.connected;
        updateUI();
      });

      state.socket.on('creator-status', (data) => {
        // Creator status changed
        updateUI();
      });

      state.socket.on('user-active-status', (data) => {
        const dot = document.querySelector('#joinerStatus .status-dot');
        if (dot) {
          dot.className = data.active ? 'status-dot status-online' : 'status-dot status-offline';
        }
      });

      state.socket.on('new-turn', (data) => {
        state.hasScratched = false;
        state.isMyTurn = (state.currentRole === data.turn);
        document.getElementById('dareText').textContent = '‚ô•Ô∏è Scratch to reveal!';
        document.getElementById('completeBtn').classList.add('hidden');
        setupCanvas();
        updateUI();
        showConnectionStatus(`üé≤ New turn: ${data.turn}`);
      });

      state.socket.on('reveal', (dare) => {
        document.getElementById('dareText').textContent = dare;
        document.getElementById('completeBtn').classList.remove('hidden');
        state.hasScratched = true;
        updateUI();
        showConnectionStatus('üíñ Dare revealed!');
      });

      state.socket.on('scratch', (data) => {
        // Receiving scratch from other player
        ctx.lineWidth = CONFIG.SCRATCH_RADIUS * 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.arc(data.x, data.y, data.radius, 0, Math.PI * 2);
        ctx.fill();
      });

      state.socket.on('room-closed', () => {
        showError('üö´ Room closed by creator. Redirecting...');
        setTimeout(() => {
          Storage.clear();
          window.location.href = window.location.pathname;
        }, 2000);
      });

      state.socket.on('error', (msg) => {
        showError(msg);
        hideLoading();
        
        if (msg.includes('Room is full')) {
          setTimeout(() => {
            Storage.clear();
            window.location.href = window.location.pathname;
          }, 3000);
        }
      });
    }

    // ===== CANVAS SETUP =====
    const canvas = document.getElementById('scratchCanvas');
    const ctx = canvas.getContext('2d');
    let dpr = 1;

    function setupCanvas() {
      // Responsive sizing
      const rect = canvas.getBoundingClientRect();
      const width = rect.width || CONFIG.CANVAS_BASE_WIDTH;
      const height = rect.height || CONFIG.CANVAS_BASE_HEIGHT;
      
      dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(width * dpr);
      canvas.height = Math.floor(height * dpr);
      
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(0, 0, width, height);
      
      document.getElementById('dareText').style.background = '#fff';
      document.getElementById('dareText').style.color = '#333';
      canvas.style.touchAction = 'none';
      ctx.globalCompositeOperation = 'destination-out';
    }

    // ===== ROOM ACTIONS =====
    async function createRoom(){
      const name = document.getElementById('roomNameInput').value
        .replace(/[<>\"'&]/g, '')
        .substring(0, 20)
        .trim();
      
      if (!name) {
        showError('Please enter a valid name');
        return;
      }

      showLoading('Creating room...');
      
      try {
        const roomId = name.toLowerCase().replace(/\s+/g, '-');
        state.currentRoom = roomId;
        state.creatorName = name;
        state.currentRole = 'creator';
        
        Storage.save();
        
        document.getElementById('creatorName').textContent = name;
        document.getElementById('inviteBtn').style.display = 'block';
        
        closeRoomPopup();
        await joinGame();
      } catch (error) {
        console.error('[CREATE] Error:', error);
        showError('Failed to create room');
        hideLoading();
      }
    }

    async function joinGame(){
      document.getElementById('welcomeScreen').classList.add('hidden');
      document.getElementById('gameScreen').style.display = 'flex';
      
      setupCanvas();
      
      // Small delay to ensure DOM is ready
      setTimeout(() => {
        if (state.socket && state.socket.connected) {
          state.socket.emit('join', {
            room: state.currentRoom,
            name: state.creatorName
          });
        }
      }, 100);
      
      // Start activity monitoring
      setInterval(() => {
        if (state.currentRoom && state.socket && state.socket.connected) {
          state.socket.emit('user-active', {
            room: state.currentRoom,
            active: state.isPageActive
          });
        }
      }, CONFIG.ACTIVE_CHECK_INTERVAL);
    }

    async function copyLink(){
      const link = document.getElementById('inviteLink');
      try {
        await navigator.clipboard.writeText(link.value);
        showConnectionStatus('üìã Link copied!');
      } catch {
        link.select();
        document.execCommand('copy');
        showConnectionStatus('üìã Link copied (fallback)');
      }
      closeInvitePopup();
    }

    // ===== CANVAS INTERACTION =====
    let isDrawing = false;
    let lastScratchTime = 0;

    function getXY(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.clientWidth / rect.width);
      const y = (e.clientY - rect.top) * (canvas.clientHeight / rect.height);
      return { x, y };
    }

    function handleScratchStart(e) {
      e.preventDefault();
      if (!state.isMyTurn || !state.joinerJoined || state.hasScratched) return;
      
      isDrawing = true;
      const pt = getXY(e);
      state.lastScratchX = pt.x;
      state.lastScratchY = pt.y;
    }

    function handleScratchMove(e) {
      e.preventDefault();
      if (!isDrawing || !state.isMyTurn || !state.joinerJoined || state.hasScratched) return;
      
      const now = Date.now();
      if (now - lastScratchTime < CONFIG.SCRATCH_DEBOUNCE_MS) return;
      lastScratchTime = now;
      
      const pt = getXY(e);
      
      // Draw locally
      ctx.lineWidth = CONFIG.SCRATCH_RADIUS * 2;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(state.lastScratchX, state.lastScratchY);
      ctx.lineTo(pt.x, pt.y);
      ctx.stroke();
      
      // Broadcast
      if (state.socket) {
        state.socket.emit('scratch', {
          room: state.currentRoom,
          x: pt.x,
          y: pt.y,
          radius: CONFIG.SCRATCH_RADIUS
        });
      }
      
      state.lastScratchX = pt.x;
      state.lastScratchY = pt.y;
    }

    function handleScratchEnd() {
      if (!state.isMyTurn) return;
      isDrawing = false;
      checkScratchComplete();
    }

    // Mouse events
    canvas.addEventListener('mousedown', handleScratchStart);
    canvas.addEventListener('mousemove', handleScratchMove);
    canvas.addEventListener('mouseup', handleScratchEnd);
    canvas.addEventListener('mouseleave', () => isDrawing = false);

    // Touch events
    canvas.addEventListener('touchstart', (e) => handleScratchStart(e.touches[0]));
    canvas.addEventListener('touchmove', (e) => handleScratchMove(e.touches[0]));
    canvas.addEventListener('touchend', handleScratchEnd);

    function checkScratchComplete(){
      try {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const img = ctx.getImageData(0, 0, width, height);
        const data = img.data;
        let transparent = 0;
        
        // Sample every nth pixel for performance
        const step = CONFIG.PIXEL_SAMPLE_RATE;
        for (let i = 3; i < data.length; i += step) {
          if (data[i] < 128) transparent++;
        }
        
        const threshold = (data.length / step) * CONFIG.SCRATCH_THRESHOLD;
        if (transparent > threshold && state.isMyTurn && !state.hasScratched) {
          state.socket.emit('scratch-complete', state.currentRoom);
          console.log('[SCRATCH] Threshold reached');
        }
      } catch (e) {
        console.error('[SCRATCH] Check error:', e);
      }
    }

    // ===== UI UPDATE =====
    function updateUI(){
      const indicator = document.getElementById('turnIndicator');
      const joinerDot = document.querySelector('#joinerStatus .status-dot');
      const completeBtn = document.getElementById('completeBtn');
      
      if (!state.joinerJoined) {
        indicator.textContent = '‚è≥ Waiting for partner to join...';
        indicator.style.color = '#333';
      } else if (state.isMyTurn && !state.hasScratched) {
        indicator.textContent = '‚ú® Your turn! Scratch to reveal';
        indicator.style.color = '#4CAF50';
      } else if (!state.isMyTurn && !state.hasScratched) {
        indicator.textContent = '‚è≥ Waiting for partner to scratch...';
        indicator.style.color = '#ff6b6b';
      } else if (state.hasScratched) {
        indicator.textContent = 'üíñ Dare revealed! Tap "Dare Completed"';
        indicator.style.color = '#ffd93d';
      }
      
      if (joinerDot) {
        joinerDot.className = state.joinerJoined ? 'status-dot status-online' : 'status-dot status-offline';
      }
      
      if (state.hasScratched && state.joinerJoined) {
        completeBtn.classList.remove('hidden');
      } else {
        completeBtn.classList.add('hidden');
      }
    }

    function completeDare() {
      if (!state.hasScratched || !state.joinerJoined) return;
      
      if (!state.socket || !state.socket.connected) {
        showError('Not connected to server');
        return;
      }
      
      state.socket.emit('done', state.currentRoom);
      document.getElementById('completeBtn').classList.add('hidden');
      state.hasScratched = false;
      showConnectionStatus('‚úÖ Dare completed!');
      updateUI();
    }

    // ===== EXIT =====
    function exitGame(){ 
      if (state.currentRole === 'creator' && state.socket) {
        state.socket.emit('exit-room', state.currentRoom);
      }
      
      if (state.socket) {
        state.socket.disconnect();
      }
      
      Storage.clear();
      
      // Use replace to prevent back button issues
      window.location.replace(window.location.pathname);
    }

    // ===== VISIBILITY & LIFECYCLE =====
    document.addEventListener('visibilitychange', () => {
      state.isPageActive = !document.hidden;
      
      if (!document.hidden && state.currentRoom) {
        // Page became active - rejoin if disconnected
        if (state.socket && !state.socket.connected) {
          showConnectionStatus('üîÑ Reconnecting...');
          state.socket.connect();
        } else if (state.socket && state.socket.connected) {
          // Rejoin room to ensure state sync
          state.socket.emit('join', {
            room: state.currentRoom,
            name: state.creatorName
          });
        }
      }
    });

    // Handle page unload
    window.addEventListener('beforeunload', () => {
      Storage.save();
    });

    // Handle resize
    window.addEventListener('resize', () => {
      if (document.getElementById('gameScreen').style.display === 'flex') {
        setupCanvas();
      }
    });

    // ===== AUTO-JOIN =====
    function handleAutoJoin() {
      const urlParams = new URLSearchParams(window.location.search);
      const roomParam = urlParams.get('room');
      
      if (roomParam) {
        showLoading('Joining room...');
        
        // Set up listener FIRST to avoid race condition
        const checkListener = (result) => {
          if (result.valid) {
            state.currentRoom = roomParam;
            state.creatorName = roomParam;
            state.currentRole = 'joiner';
            document.getElementById('creatorName').textContent = roomParam;
            document.getElementById('inviteBtn').style.display = 'none';
            Storage.save();
            
            setTimeout(() => joinGame(), 300);
          } else {
            showError(result.error || 'Room not available');
            hideLoading();
            setTimeout(() => {
              window.location.href = window.location.pathname;
            }, 3000);
          }
        };
        
        state.socket.once('room-check-result', checkListener);
        state.socket.emit('check-room', roomParam);
      }
    }

    // ===== INITIALIZATION =====
    document.addEventListener('DOMContentLoaded', () => {
      initSocket();
      
      // Wait for socket to be ready before auto-join
      state.socket.on('connect', () => {
        handleAutoJoin();
      });
      
      // If socket is already connected (unlikely but possible)
      if (state.socket.connected) {
        handleAutoJoin();
      }
    });
  </script>
</body>
</html>
